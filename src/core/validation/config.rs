//! Entity validation configuration
//!
//! This module provides the configuration structure that holds validators and filters
//! for an entity. It's generated by the macro system.

use anyhow::Result;
use serde_json::Value;
use std::collections::HashMap;

/// Type alias for validator function
type ValidatorFn = Box<dyn Fn(&str, &Value) -> Result<(), String> + Send + Sync>;

/// Type alias for filter function
type FilterFn = Box<dyn Fn(&str, Value) -> Result<Value> + Send + Sync>;

/// Configuration for validating and filtering an entity
pub struct EntityValidationConfig {
    /// Entity type name
    pub entity_type: String,

    /// Validators by field name
    validators: HashMap<String, Vec<ValidatorFn>>,

    /// Filters by field name
    filters: HashMap<String, Vec<FilterFn>>,
}

impl EntityValidationConfig {
    /// Create a new validation config for an entity
    pub fn new(entity_type: &str) -> Self {
        Self {
            entity_type: entity_type.to_string(),
            validators: HashMap::new(),
            filters: HashMap::new(),
        }
    }

    /// Add a validator for a specific field
    pub fn add_validator<F>(&mut self, field: &str, validator: F)
    where
        F: Fn(&str, &Value) -> Result<(), String> + Send + Sync + 'static,
    {
        self.validators
            .entry(field.to_string())
            .or_default()
            .push(Box::new(validator));
    }

    /// Add a filter for a specific field
    pub fn add_filter<F>(&mut self, field: &str, filter: F)
    where
        F: Fn(&str, Value) -> Result<Value> + Send + Sync + 'static,
    {
        self.filters
            .entry(field.to_string())
            .or_default()
            .push(Box::new(filter));
    }

    /// Validate and filter a complete payload
    ///
    /// Returns the filtered payload or a list of validation errors
    pub fn validate_and_filter(&self, mut payload: Value) -> Result<Value, Vec<String>> {
        let mut errors = Vec::new();

        // Step 1: Apply all filters
        if let Some(obj) = payload.as_object_mut() {
            for (field, value) in obj.iter_mut() {
                if let Some(field_filters) = self.filters.get(field) {
                    for filter in field_filters {
                        match filter(field, value.clone()) {
                            Ok(filtered) => *value = filtered,
                            Err(e) => {
                                errors.push(format!("Erreur de filtrage sur '{}': {}", field, e));
                            }
                        }
                    }
                }
            }
        }

        // Step 2: Apply all validators
        if let Some(obj) = payload.as_object() {
            for (field, value) in obj.iter() {
                if let Some(field_validators) = self.validators.get(field) {
                    for validator in field_validators {
                        if let Err(e) = validator(field, value) {
                            errors.push(e);
                        }
                    }
                }
            }
        }

        if errors.is_empty() {
            Ok(payload)
        } else {
            Err(errors)
        }
    }
}
